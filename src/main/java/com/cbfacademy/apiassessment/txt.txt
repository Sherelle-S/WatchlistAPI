package com.cbfacademy.apiassessment;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

// import com.cbfacademy.apiassessment.WatchlistRepository;
// annotations tell spring this is the class where everything will run from, its also a controller with the ability to map requests, componentScan let spring know this is a base class, everything show be variable from here.
@SpringBootApplication
@RestController
@ComponentScan(basePackages = "com.cbfacademy.apiassessment")
public class App implements CommandLineRunner{

	
	/** 
	 * @param args
	 */
	public static void main(String[] args) {
		
		SpringApplication.run(App.class, args);
	}

	@GetMapping("/greeting")
	public String greeting(@RequestParam(value = "name", defaultValue = "World") String name) {
			return String.format("Hello %s", name);
			
	}

	@Override
    public void run(String... args) throws Exception {
		}
	}


package com.cbfacademy.apiassessment.service;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.UUID;

import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

import com.cbfacademy.apiassessment.controller.WatchlistController;
import com.cbfacademy.apiassessment.crudActions.appendingActions.createEntry.CreateFirstItem;
import com.cbfacademy.apiassessment.crudActions.appendingActions.createEntry.RunCreatingActions;
import com.cbfacademy.apiassessment.crudActions.appendingActions.deleteEntries.RunDeleteEntry;
import com.cbfacademy.apiassessment.crudActions.appendingActions.read.ReadExistingWatchlist;
import com.cbfacademy.apiassessment.crudActions.appendingActions.read.searchAndSort.BinarySearch;
import com.cbfacademy.apiassessment.crudActions.appendingActions.read.searchAndSort.SortWatchlistByName;
import com.cbfacademy.apiassessment.crudActions.appendingActions.updateOneEntry.RunUpdatingMethods;
import com.cbfacademy.apiassessment.exceptions.WatchlistDataAccessException;
import com.cbfacademy.apiassessment.exceptions.InvalidInputException;
import com.cbfacademy.apiassessment.exceptions.ItemNotFoundException;
import com.cbfacademy.apiassessment.model.Watchlist;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

// service layer, holds business logic to controller methods 
@Service
@Component
public class WatchlistServiceImpl implements WatchlistService {

    String jsonRepo = "JsonWatchlist.json";

    @Autowired
    private BinarySearch binarySearch;
    private CreateFirstItem createFirstItem;
    private ObjectMapper mapper;
    private RunCreatingActions runCreateItem;
    private RunDeleteEntry deleteEntry;
    private ReadExistingWatchlist readList;
    private RunUpdatingMethods runUpdatingMethods;
    private SortWatchlistByName sortByName;
    
    // private UpdatePutEntry updateOneEntry;

    public WatchlistServiceImpl(BinarySearch binarySearch, CreateFirstItem createFirstItem, RunDeleteEntry deleteEntry, ObjectMapper mapper, RunCreatingActions runCreateItem, RunUpdatingMethods runUpdatingMethods, SortWatchlistByName sortByName, ReadExistingWatchlist readList) {
        this.binarySearch = binarySearch;
        this.createFirstItem = createFirstItem;
        this.deleteEntry = deleteEntry;
        this.mapper = mapper.registerModule(new JavaTimeModule());
        this.mapper = mapper;
        this.runCreateItem = runCreateItem;
        this.runUpdatingMethods = runUpdatingMethods;
        this.readList = readList;
        this.sortByName = sortByName;
    }

    private static final Logger log = LoggerFactory.getLogger(WatchlistController.class);

    // return response entity for creating watchlist

    public List<Watchlist> getCurrentWatchlist() throws IOException{
        // try {
            List<Watchlist> currentWatchlist = readList.readExistingWatchlist(jsonRepo, mapper);
            return currentWatchlist;
        // } catch (WatchlistDataAccessException e) {
        //     log.error("Watchlist data cannot be accessed, problem in watchlist service implementations", e.getMessage());
        //     throw new IOException(e.getMessage());
            
        // }
        
    }
    @Override
    public ResponseEntity<Void> create(List<Watchlist> watchlist) throws WatchlistDataAccessException {
        try {
            File file = new File(jsonRepo);
            if(!file.exists()){
                file.createNewFile();
                createFirstItem.CreateFirstEntry(watchlist, jsonRepo);
                return new ResponseEntity<>(HttpStatus.CREATED);
            } else if(file.exists() && file.length() == 0) {
                createFirstItem.CreateFirstEntry(watchlist, jsonRepo);
                return new ResponseEntity<>(HttpStatus.CREATED);
            } else {
                runCreateItem.appendNewItems(watchlist, jsonRepo);
                // runCreateItem.appendNewItems(watchlist, watchlist, jsonRepo);
                return new ResponseEntity<>(HttpStatus.CREATED);
            }
        } catch (Exception e) {
            log.error("Error processing file: " + e.getMessage());
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    // return response entity and watchlist for read requests
    @Override
    public ResponseEntity<List<Watchlist>> readWatchlist() {
        try {
            List<Watchlist> retrieveWatchlist = getCurrentWatchlist();;
            if(retrieveWatchlist.size() <= 0){
                return (ResponseEntity<List<Watchlist>>) ResponseEntity.noContent();
            } else {
                return ResponseEntity.ok(retrieveWatchlist);
            }
        } catch (IOException e) {
            log.error("Get Watchlist has Triggered IOException in watchlist Service Implementation", e.getMessage());
            return new ResponseEntity<>(HttpStatus.SERVICE_UNAVAILABLE);
        }
    }

    // logic for returning sorted watchlist
    @Override
    public ResponseEntity<List<Watchlist>> sortedWatchlist() throws WatchlistDataAccessException {
            
            try {
                List<Watchlist> quickSortWatchlist = sortByName.sortedWatchlist(getCurrentWatchlist(), jsonRepo, mapper);
                return ResponseEntity.ok(quickSortWatchlist);
            } catch (IOException e) {
                log.error("IOException while attempting to sort watchlist by name.", e.getMessage());
                return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);            
        }
    }

    @Override
    public ResponseEntity<Watchlist> searchByName(String name) throws InvalidInputException{
        try {
            log.info("service impl name is" + name );
            Watchlist searchResult = binarySearch.binarySearchWatchlist(getCurrentWatchlist(), name);
            return  ResponseEntity.ok(searchResult);
        } catch (ItemNotFoundException e) {
            log.error(name + "Not found in existing watchlist", e.getMessage());
            return ResponseEntity.notFound().build();
        } catch (InvalidInputException e) {
            log.error(name + "Is an invalid input", e.getMessage());
            return ResponseEntity.noContent().build();
        } catch (IOException e) {
            log.error("Exception ocurred while accessing json data", e.getMessage());
            return ResponseEntity.internalServerError().build();
        }
    }

    // returns logic for updating entries
    @Override
    public ResponseEntity<Void> updateEntry(UUID uuid, Watchlist newEntry) {

        try {
            List<Watchlist> existingWatchlist = getCurrentWatchlist();
            try {
                runUpdatingMethods.runUpdatingMethods(existingWatchlist, jsonRepo, newEntry, uuid);
            } catch (ParseException e) {
                log.error("Exception ocurred while parsing json data in watchlistServiceImplementation to update PUT request", e.getMessage());
                e.printStackTrace();
            }
            return new ResponseEntity<>(HttpStatus.CREATED);
        } catch (ItemNotFoundException e) {
            log.error("Could not find item in watchlist with corresponding uuid in updateEntry method watchlist service implementation.", e.getMessage());
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        } catch (IOException e) {
            log.error("IOException has been triggered while updating entry in watchlist service implementation.", e.getMessage());
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    // returns logic for deleting watchlist entries
    @Override
    public ResponseEntity<List<Watchlist>> deleteWatchlistEntry(UUID uuid) throws IOException {
        List<Watchlist> existingWatchlist = getCurrentWatchlist();
        log.info("delete watchlist has been called.");
        log.info("watchlist at deleteEntry in service {}", existingWatchlist);
        try {
            deleteEntry.runDeleteItem(existingWatchlist, jsonRepo, mapper, uuid);
            return new ResponseEntity<>(HttpStatus.OK);
        } catch (InvalidInputException e) {
            log.error("Invalid input received", e.getMessage());
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        } catch (ItemNotFoundException e) {
            log.error("Unable to locate requested item", e.getMessage());
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        } catch (IOException e) {
            log.error("IOException has taken place in watchlist Service implementation while attempting to run method deleteEntry", e.getMessage());
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
}

package com.cbfacademy.apiassessment.service;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.UUID;

import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

import com.cbfacademy.apiassessment.controller.WatchlistController;
import com.cbfacademy.apiassessment.crudActions.appendingActions.createEntry.CreateFirstItem;
import com.cbfacademy.apiassessment.crudActions.appendingActions.createEntry.RunCreatingActions;
import com.cbfacademy.apiassessment.crudActions.appendingActions.deleteEntries.RunDeleteEntry;
import com.cbfacademy.apiassessment.crudActions.appendingActions.read.ReadExistingWatchlist;
import com.cbfacademy.apiassessment.crudActions.appendingActions.read.searchAndSort.BinarySearch;
import com.cbfacademy.apiassessment.crudActions.appendingActions.read.searchAndSort.SortWatchlistByName;
import com.cbfacademy.apiassessment.crudActions.appendingActions.updateOneEntry.RunUpdatingMethods;
import com.cbfacademy.apiassessment.exceptions.WatchlistDataAccessException;
import com.cbfacademy.apiassessment.exceptions.InvalidInputException;
import com.cbfacademy.apiassessment.exceptions.ItemNotFoundException;
import com.cbfacademy.apiassessment.model.Watchlist;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

// service layer, holds business logic to controller methods 
@Service
@Component
public class WatchlistServiceImpl implements WatchlistService {

    String jsonRepo = "JsonWatchlist.json";

    @Autowired
    private BinarySearch binarySearch;
    private CreateFirstItem createFirstItem;
    private ObjectMapper mapper;
    private RunCreatingActions runCreateItem;
    private RunDeleteEntry deleteEntry;
    private ReadExistingWatchlist readList;
    private RunUpdatingMethods runUpdatingMethods;
    private SortWatchlistByName sortByName;
    
    // private UpdatePutEntry updateOneEntry;

    public WatchlistServiceImpl(BinarySearch binarySearch, CreateFirstItem createFirstItem, RunDeleteEntry deleteEntry, ObjectMapper mapper, RunCreatingActions runCreateItem, RunUpdatingMethods runUpdatingMethods, SortWatchlistByName sortByName, ReadExistingWatchlist readList) {
        this.binarySearch = binarySearch;
        this.createFirstItem = createFirstItem;
        this.deleteEntry = deleteEntry;
        this.mapper = mapper.registerModule(new JavaTimeModule());
        this.mapper = mapper;
        this.runCreateItem = runCreateItem;
        this.runUpdatingMethods = runUpdatingMethods;
        this.readList = readList;
        this.sortByName = sortByName;
    }

    private static final Logger log = LoggerFactory.getLogger(WatchlistController.class);

    // return response entity for creating watchlist

    public List<Watchlist> getCurrentWatchlist() throws IOException{
            List<Watchlist> currentWatchlist = readList.readExistingWatchlist(jsonRepo, mapper);
            return currentWatchlist;
        
    }
    
    @Override
    public ResponseEntity<Void> create(List<Watchlist> watchlist) throws WatchlistDataAccessException {
        try {
            File file = new File(jsonRepo);
            if(!file.exists()){
                file.createNewFile();
                createFirstItem.CreateFirstEntry(watchlist, jsonRepo);
                return new ResponseEntity<>(HttpStatus.CREATED);
            } else if(file.exists() && file.length() == 0) {
                createFirstItem.CreateFirstEntry(watchlist, jsonRepo);
                return new ResponseEntity<>(HttpStatus.CREATED);
            } else {
                runCreateItem.appendNewItems(watchlist, jsonRepo);
                // runCreateItem.appendNewItems(watchlist, watchlist, jsonRepo);
                return new ResponseEntity<>(HttpStatus.CREATED);
            }
        } catch (Exception e) {
            log.error("Error processing file: " + e.getMessage());
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    // return response entity and watchlist for read requests
    @Override
    public ResponseEntity<List<Watchlist>> readWatchlist() {
        try {
            List<Watchlist> retrieveWatchlist = getCurrentWatchlist();;
            if(retrieveWatchlist.size() <= 0){
                return (ResponseEntity<List<Watchlist>>) ResponseEntity.noContent();
            } else {
                return ResponseEntity.ok(retrieveWatchlist);
            }
        } catch (IOException e) {
            log.error("Get Watchlist has Triggered IOException in watchlist Service Implementation", e.getMessage());
            return new ResponseEntity<>(HttpStatus.SERVICE_UNAVAILABLE);
        }
    }

    // logic for returning sorted watchlist
    @Override
    public ResponseEntity<List<Watchlist>> sortedWatchlist() throws WatchlistDataAccessException {
            
            try {
                List<Watchlist> quickSortWatchlist = sortByName.sortedWatchlist(getCurrentWatchlist(), jsonRepo, mapper);
                return ResponseEntity.ok(quickSortWatchlist);
            } catch (IOException e) {
                log.error("IOException while attempting to sort watchlist by name.", e.getMessage());
                return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);            
        }
    }

    @Override
    public ResponseEntity<Watchlist> searchByName(String name) throws InvalidInputException{
        try {
            log.info("service impl name is" + name );
            Watchlist searchResult = binarySearch.binarySearchWatchlist(getCurrentWatchlist(), name);
            return  ResponseEntity.ok(searchResult);
        } catch (ItemNotFoundException e) {
            log.error(name + "Not found in existing watchlist", e.getMessage());
            return ResponseEntity.notFound().build();
        } catch (InvalidInputException e) {
            log.error(name + "Is an invalid input", e.getMessage());
            return ResponseEntity.noContent().build();
        } catch (IOException e) {
            log.error("Exception ocurred while accessing json data", e.getMessage());
            return ResponseEntity.internalServerError().build();
        }
    }

    // returns logic for updating entries
    @Override
    public ResponseEntity<Void> updateEntry(UUID uuid, Watchlist newEntry) {

        try {
            List<Watchlist> existingWatchlist = getCurrentWatchlist();
            try {
                runUpdatingMethods.runUpdatingMethods(existingWatchlist, jsonRepo, newEntry, uuid);
            } catch (ParseException e) {
                log.error("Exception ocurred while parsing json data in watchlistServiceImplementation to update PUT request", e.getMessage());
                e.printStackTrace();
            }
            return new ResponseEntity<>(HttpStatus.CREATED);
        } catch (ItemNotFoundException e) {
            log.error("Could not find item in watchlist with corresponding uuid in updateEntry method watchlist service implementation.", e.getMessage());
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        } catch (IOException e) {
            log.error("IOException has been triggered while updating entry in watchlist service implementation.", e.getMessage());
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    // returns logic for deleting watchlist entries
    @Override
    public ResponseEntity<List<Watchlist>> deleteWatchlistEntry(UUID uuid) throws IOException {
        List<Watchlist> existingWatchlist = getCurrentWatchlist();
        log.info("delete watchlist has been called.");
        log.info("watchlist at deleteEntry in service {}", existingWatchlist);
        try {
            deleteEntry.runDeleteItem(existingWatchlist, jsonRepo, mapper, uuid);
            return new ResponseEntity<>(HttpStatus.OK);
        } catch (InvalidInputException e) {
            log.error("Invalid input received", e.getMessage());
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        } catch (ItemNotFoundException e) {
            log.error("Unable to locate requested item", e.getMessage());
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        } catch (IOException e) {
            log.error("IOException has taken place in watchlist Service implementation while attempting to run method deleteEntry", e.getMessage());
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
}




package com.cbfacademy.apiassessment.service;

import java.io.IOException;
import java.util.List;
import java.util.UUID;

import org.springframework.http.ResponseEntity;

import com.cbfacademy.apiassessment.exceptions.InvalidInputException;
import com.cbfacademy.apiassessment.exceptions.WatchlistDataAccessException;
import com.cbfacademy.apiassessment.model.Watchlist;

// interface that tells watchlist service what methods it needs to implement but not how to implement them.
public interface WatchlistService {

    ResponseEntity<Void> create(List<Watchlist> watchlist) throws WatchlistDataAccessException;

    ResponseEntity<List<Watchlist>> readWatchlist() throws WatchlistDataAccessException;

    ResponseEntity<List<Watchlist>> sortedWatchlist() throws WatchlistDataAccessException;

    public ResponseEntity<Watchlist> searchByName(String name) throws InvalidInputException;

    ResponseEntity<Void> updateEntry(UUID uuid, Watchlist newEntry);

    ResponseEntity<List<Watchlist>> deleteWatchlistEntry(UUID uuid) throws IOException;

} 
package com.cbfacademy.apiassessment.model;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

import org.json.simple.JSONObject;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.annotation.JsonFormat;

// model that shows the structure for the watchlist
@Component
public class Watchlist {

    private UUID uuid;
    private String stockName;
    private String symbol;
     private String currency;
    @JsonFormat(pattern = "dd/MM/yyyy")
    private LocalDate datePurchased;
    private Integer wantsVolStock;
    private Integer ownsVolStock;
    private double purchasePrice;
    private double currentPrice;
    private double profit;
    private double pointsChange;
    private double open;
    private double close;
    private double intradayHigh;

    public Watchlist() {
    }

    // generating uuid with this constructor and implementing the logic so that it is generated if uuid is null
    public Watchlist(UUID uuid, String stockName, String symbol, String currency, LocalDate datePurchased, Integer ownsVolStock, Integer wantsVolStock, double purchasePrice, double currentPrice, double profit, double pointsChange, double open, double close, double intradayHigh) {
        this.uuid = uuid == null ? UUID.randomUUID() : uuid;
        this.stockName = stockName;
        this.symbol = symbol;
        this.currency = currency;
        this.datePurchased = datePurchased;
        this.ownsVolStock = ownsVolStock;
        this.wantsVolStock = wantsVolStock;
        this.purchasePrice = purchasePrice;
        this.currentPrice = currentPrice;
        this.profit = profit;
        this.pointsChange = pointsChange;
        this.open = open;
        this.close = close;
        this.intradayHigh = intradayHigh;
    }

        public Watchlist(JSONObject json){
            Object uuidObj = json.get("uuid");
            if (uuidObj instanceof String) {
                this.uuid = UUID.fromString((String) uuidObj);
            } else {
                this.uuid = UUID.randomUUID();
            }
        this.stockName = (String) json.get("stockName");
        this.symbol = (String) json.get("symbol");
        this.currency = (String) json.get("currency");
        String datePurchasedStr = (String) json.get("datePurchased");
        this.datePurchased = LocalDate.parse(datePurchasedStr, DateTimeFormatter.ofPattern("dd/MM/yyyy"));
        this.ownsVolStock = (Integer) json.get("ownsVolStock");
        this.wantsVolStock = (Integer) json.get("wantsVolStock");
        this.profit = (double) json.get("profit");
        this.pointsChange = (double) json.get("pointsChange");
        this.open = (double) json.get("open");
        this.close = (double) json.get("close");
        this.intradayHigh = (double) json.get("intradayHigh");
    }

        public Watchlist(String currency, LocalDate datePurchased, Integer ownsVolStock, Integer wantsVolStock, double purchasePrice, double currentPrice, double profit, double pointsChange, double open, double close, double intradayHigh) {
        this.currency = currency;
        this.datePurchased = datePurchased;
        this.ownsVolStock = ownsVolStock;
        this.wantsVolStock = wantsVolStock;
        this.purchasePrice = purchasePrice;
        this.currentPrice = currentPrice;
        this.profit = profit;
        this.pointsChange = pointsChange;
        this.open = open;
        this.close = close;
        this.intradayHigh = intradayHigh;
    }

    public UUID getUuid() {
        return uuid;
    }

    public void setUuid(UUID uuid) {
        this.uuid = uuid;
    }

    public String getStockName() {
        return stockName;
    }

    public void setStockName(String stockName) {
        this.stockName = stockName;
    }

    public String getSymbol() {
        return symbol;
    }

    public void setSymbol(String symbol) {
        this.symbol = symbol;
    }

    public String getCurrency() {
        return currency;
    }

    public void setCurrency(String currency) {
        this.currency = currency;
    }

    public LocalDate getDatePurchased() {
        return datePurchased;
    }

    public void setDatePurchased(LocalDate datePurchased) {
        this.datePurchased = datePurchased;
    }

    public Integer getOwnsVolStock() {
        return ownsVolStock;
    }

    public void setOwnsVolStock(Integer has) {
        this.ownsVolStock = has;
        calculateProfit();
    }

    public Integer getWantsVolStock() {
        return wantsVolStock;
    }

    public void setWantsVolStock(Integer wants) {
        this.wantsVolStock = wants;
    }

    public double getPurchasePrice() {
        return purchasePrice;
    }
    public void setPurchasePrice(double purchasePrice) {
        this.purchasePrice = purchasePrice;
        calculateProfit();
    }
    public double getCurrentPrice() {
        return currentPrice;
    }
    public void setCurrentPrice(double currentPrice) {
        this.currentPrice = currentPrice;
        calculateProfit();
    }

    public double getProfit() {
        return profit;
    }

    public void setProfit(double profit) {
        this.profit = (getOwnsVolStock() * getCurrentPrice()) - (getOwnsVolStock() * getPurchasePrice());
    }

    private void calculateProfit() {
        this.pointsChange = this.ownsVolStock * this.currentPrice - this.ownsVolStock * this.purchasePrice; 
    }

    public double getPointsChange() {
        return pointsChange;
    }

    // logic for setting points change automatically based on user input
    public void setPointsChange(double pointsChange) {
        this.pointsChange = getClose() - getOpen();
    }

    public double getOpen() {
        return open;
    }

    public void setOpen(double open) {
        this.open = open;
        calculatePointsChange();
    }

    public double getClose() {
        return close;
    }

    public void setClose(double close) {
        this.close = close;
        calculatePointsChange();
    }

    private void calculatePointsChange() {
        this.pointsChange = this.close - this.open; 
    }

    public double getIntradayHigh() {
        return intradayHigh;
    }

    public void setIntradayHigh(double intradayHigh) {
        this.intradayHigh = intradayHigh;
    }

    @Override
    public String toString() {
        return "Watchlist [uuid=" + uuid + ", stockName=" + stockName + ", symbol=" + symbol + "currency=" + currency + ", datePurchased=" + datePurchased + ", has=" + ownsVolStock + ", wants=" + wantsVolStock + ", profit=" + profit + ", pointsChange=" + pointsChange + ", open=" + open + ", close=" + close + ", intradayHigh=" + intradayHigh + "]";
    }
}


package com.cbfacademy.apiassessment.crudActions.appendingActions.updateOneEntry;

import java.io.IOException;
import java.util.List;
import java.util.UUID;

import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;

import com.cbfacademy.apiassessment.crudActions.appendingActions.createEntry.RunCreatingActions;
import com.cbfacademy.apiassessment.crudActions.appendingActions.createEntry.WriteToJsonFile;
import com.cbfacademy.apiassessment.crudActions.appendingActions.read.ReadExistingWatchlist;
import com.cbfacademy.apiassessment.exceptions.ItemNotFoundException;
import com.cbfacademy.apiassessment.model.Watchlist;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

/**
 * Handles the methods related to updating watchlist entries.
 */
@Component
public class RunUpdatingMethods {
    
    /** Logger for logging events within this class. */
    private static final Logger log = LoggerFactory.getLogger(RunCreatingActions.class);

    /** Object Mapper for JSON serialization and deserialization. */
    @Autowired
    private ObjectMapper mapper;

    /** Reads existing watchlist data. */
    private ReadExistingWatchlist readList;

    /** Writes updated watchlist data to JSON. */
    private WriteToJsonFile writeToJson;

    /** Handles updating individual watchlist entries. */
    private UpdatePutEntry updateOneEntry;

    /**
     * Constructs a RunUpdatingMethods instance.
     * 
     * @param mapper         ObjectMapper for JSON processing.
     * @param readList       Reads existing watchlist data.
     * @param writeToJson    Writes updated watchlist data to JSON.
     * @param updateOneEntry Handles updating individual watchlist entries.
     */
    public RunUpdatingMethods(ObjectMapper mapper, ReadExistingWatchlist readList,
            WriteToJsonFile writeToJson, UpdatePutEntry updateOneEntry) {
        this.mapper = mapper.registerModule(new JavaTimeModule());
        this.readList = readList;
        this.writeToJson = writeToJson;
        this.updateOneEntry = updateOneEntry;
    }

    
    /** 
     * @param watchlist
     * @param jsonRepo
     * @param newEntry
     * @param uuid
     * @return ResponseEntity<Void>
     * @throws ParseException
     */
    // runs all the components for updating one entry of watchlist 
    public ResponseEntity<Void> runUpdatingMethods(List<Watchlist> watchlist, String jsonRepo, Watchlist newEntry, UUID uuid) throws ParseException{
        try {
            readList.readExistingWatchlist(jsonRepo, mapper);
            updateOneEntry.updateEntryViaUuid(watchlist, uuid, newEntry);
            writeToJson.writeToJson(jsonRepo, mapper, watchlist);
            log.info("Watchlist entry has successfully been updated.");
            return new ResponseEntity<>(HttpStatus.CREATED);
        } catch (ItemNotFoundException e) {
            log.error("The item that you are looking for could not be located", e);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        } catch (IOException e ) {
            log.error("An error has ocurred while trying to update watchlist with your request.", e);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }
}
